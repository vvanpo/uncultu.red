<!DOCTYPE html>

<title>October 4, 2022 | uncultu.red</title>
<link href="/style.css" rel="stylesheet">
<meta name="viewport" content="width=device-width">

<p>
  I’m a big proponent of “owning your own data”. To me, what that means is not necessarily that I keep a RAID array under my bed, but that my data is 1. easy to export from wherever it’s currently stored, and 2. in some kind of interoperable format. For most of my data, both are significant issues. For example: I think Apple Photos and Google Photos are both fantastic applications, and both work seamlessly within their respective ecosystems. Both are better than anything I use, in terms of managing albums, tagging, sorting, maintaining multiple variations of a source image, filtering by location, date, or even contents like people’s faces, etc. But I couldn’t export my entire collection from Google Photos in a way that maintains albums/tags/variation collections and is interoperable with other services. I couldn’t maintain a synchronized copy of the underlying data locally or on some other platform, at least not since Google removed access to the storage layer when it divorced Photos from Drive. Combine that with the fact that these companies make significant breaking changes to their services on the regular, have track records of user-hostile decisions, will presumably hand over your data to any authority that asks them to or shut down your access when some bot determines you’ve violated a policy, and I just <a href="https://web.archive.org/web/20220827001129/https://rohanrd.xyz/posts/why-you-should-start-self-hosting/">don’t trust most services with my data</a>.

<p>
  And so I keep most things in a filesystem, stored in Dropbox. Although Dropbox clients by default load files transparently through the network only at time of access, I could potentially keep a fully synchronized backup (I could maintain a server that mounts the Dropbox folder atop an S3-backed filesystem, or I could decide to keep that RAID array under my bed after all), although I don’t currently (and I have too much data to keep it all on my laptop). For most of my data, all I really want is a reasonable way to organize and search it. Google and Apple services do this really, really well, but a filesystem can be sort-of-okay too. To take the photos example again, I maintain folders for every year, wherein I put folders for every month, and most of the time I don’t have too much trouble when I’m looking back to find a certain photo (although generally it’s most helpful to use a viewer that can flatten the entire folder hierarchy and just let you scroll thumbnails of the entire collection). But this kind of organization breaks down pretty quickly when you’re looking for a particular photo but can’t really remember when it was taken, or when you’re looking for all photos of a particular type. And I keep separate folders for curated albums, where I now have to copy individual photos or export edited versions of photos, with no way to link back to the originals (Dropbox has to use the subset of filesystem APIs that is interoperable across systems, so no symbolic links). I also sometimes store photos that people have sent me, but want to make sure I know who sent me what photo, so I have separate folders for everyone’s names, and therein I generally don’t keep another hierarchy for year/month or any other metadata. All this to say that folder structures are not sufficient for
organizing my data in a consistent way.

<p>
  I blame hierarchical filesystems. Filesystems and files are fantastic at abstracting storage details, but someone messed it all up by adding paths. File paths are interesting because each path is a combination of what I will call extrinsic and intrinsic metadata. “Intrinsic” metadata is what stays with the file as it’s passed around: the file name and extension, metadata encoded within the file itself (think Exif for images or ID3 for MP3s), etc. Extrinsic metadata in the context of a filesystem might be its location (i.e. <code>dirname</code>), ownership and access control, created/last-modified/last-accessed timestamps… and that’s about all I can think of right now. Ideally, you would want extrinsic metadata to include anything personal to you or your system’s usage of the file, whereas intrinsic metadata should be exclusive to that which is invariant regardless of where the file is stored or used. But filesystem APIs don’t really encourage you to make use of this distinction; your only OS-supported functionality is to read the list of filenames in a given directory, so you’re stuck walking the tree when looking for files and are likely to build that tree based on whatever metadata seems most useful for future browsing—extrinsic or not. In my photos example, I have a folder structure that results in picture pathnames prefixed by the date they were taken, even though this date is an example of intrinsic metadata (and redundant, all my photos already have the date stored internally via Exif). Hierarchical filesystems only give me one choice for categorization/locality, so I chose an intrinsic property as that’s hopefully the most useful way for me to browse pictures.

<p>
  Filenames are of dubious usefulness too. Most filenames on my computer—photos, screenshots, songs, ebooks—come from someplace other than my keyboard; they are determined by either the program that created them, or generated using metadata by the program I used to import them. Some cameras (like my phone) give each picture its timestamp as a filename, whereas others assign an opaque sequential identifier (which inevitably ends up in collisions when using multiple cameras from the same manufacturer or when reformatting a card). The sequential identifiers I can do without, because it’s not super interesting to me whether a given picture is my camera’s 2332nd shutter release (or at least, not so important that it needs to be the filename), and timestamps are once again redundant. Even when I create new documents and manually decide on a filename, it’s often a combination of some content or metadata that is already present in the document itself.

<p>
  I’d say I’m fairly meticulous about keeping my data organized and in one place to the extent that’s feasible, and yet I can’t help but notice that every hierarchical structure I need to maintain inevitably ends up a mess. All the folders in my Dropbox account, all my browser bookmarks, e-mail folders, passwords in my KeePass database, etc. Every time I need to retrieve my data I get the same nagging feeling as when I open a messy desk drawer and think to myself “ugh, I really need to get around to reorganizing this stuff.” When I observe others using a computer, they generally seem to treat their filesystem as a pit to throw things into without any expectation of being able to retrieve it later.

<p>
  I know what you might say to this: “Victor, stop complaining about filesystems, it’s your tools that suck. The fact that your file browser can’t filter and sort images by Exif properties is not the filesystem’s fault”. Well there is a lot of truth to that, you’re right, good observation. If the file browsing tools I have access to on all the various platforms I use (Finder on my work Macbook, the Dropbox client and Files app on my Android phone, the Dropbox Web client, Windows file explorer on my laptop, <code>ls</code> and other Unix tools, etc.) all natively supported every kind of intrinsic metadata available and were able to easily search, sort, and filter by them, that would certainly make my life a lot easier. Some of them aren’t terrible, most users of iOS and Android don’t have to think about file hierarchies very much, and generally just select by filetype and scroll when they need to find something. If all platforms had perfect file browsers, I would probably end up using very flat folder structures, but I’d still end up with issues where trying to put a file into more than one category forces me to create duplicate folders across arbitrary hierarchies. Another significant problem would be resource usage when querying metadata on a networked filesystem. Paths, filenames, and anything returned by <code>stat</code> are cheap to query because they’re supported natively by the filesystem, and even reproducing the entire file tree wouldn’t require much data transfer. But if I wanted to query an arbitrary metadata property that could be encoded within any file, I’d have to pull down hundreds of gigabytes from Dropbox.

<p>
  So where does that leave us? Well, nowhere really. Files are universal and are interoperable precisely because they’re just a big bucket of bytes; trying to standardize some form of in-band metadata would never work, and not just because it would essentially be a breaking change for every piece of technology in existence. A metadata sidecar wouldn’t work either, much for the same reason and because it would ruin the whole stream-of-bytes ⇔ file equivalency that so many things depend on. And as for paths, well they’re obviously here to stay. When an application wants to open a file, it does so by requesting a path first; so even if you could build the most beautiful non-hierarchical (multi-hierarchical?) filesystem and file browser of your dreams (say, backed by a folder in regular filesystem and a sqlite database to track all the tags), clicking on a file would still require your filesystem to pass through that original path to the application registered with your OS to open that filetype, making your filesystem abstraction very leaky.

<p>
  tl;dr: inodes are cool, dentrys are dumb. Hate trees, love graphs.
